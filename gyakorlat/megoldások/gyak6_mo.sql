/*1. Hozzunk létre egy sorszámgenerátort (Sequence) 
és kérdezzük le a következõ értékét, aktuális értékét!*/

CREATE SEQUENCE sorszámpróba START WITH 1000 INCREMENT BY 10;
SELECT sorszámpróba.nextval FROM dual;
SELECT sorszámpróba.currval FROM dual;

/*2. Töröljük ki az összes táblánakat és sorozatunkat!*/

SELECT * FROM user_objects
ORDER BY object_type;

SELECT 
'drop '|| object_type ||' '
||object_name
||case when lower(object_type)='table' then ' purge;' else ';' end Lefuttatni
FROM user_objects
where lower(object_type) in ('table','sequence') and lower(generated)='n'
ORDER BY created DESC;

select * from user_objects;

/*3. Hozzunk létre egy KOLCSONZO táblát, azonosító és név legyen benne. 
Az azonosító automatikusan generálódjon!*/

CREATE TABLE kolcsonzo
(kid NUMBER(4) GENERATED AS IDENTITY PRIMARY KEY
,nev VARCHAR2(40));

INSERT INTO kolcsonzo
VALUES(
10
,'Mézga Géza'
);

INSERT INTO kolcsonzo(nev)
VALUES('Mézga Géza');
INSERT INTO kolcsonzo(nev)
VALUES('Mézga Aladár');
INSERT INTO kolcsonzo(nev)
VALUES('Hufnágel Pisti');

SELECT * FROM kolcsonzo;
ROLLBACK;

COMMIT;


DROP TABLE kolcsonzo PURGE;

CREATE TABLE kolcsonzo
(kid NUMBER(4) GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
,nev VARCHAR2(40));

INSERT INTO kolcsonzo
VALUES(
10
,'Mézga Géza'
);


INSERT INTO kolcsonzo(nev)
VALUES('Mézga Géza');
INSERT INTO kolcsonzo(nev)
VALUES('Mézga Aladár');
INSERT INTO kolcsonzo(nev)
VALUES('Hufnágel Pisti');

SELECT * FROM kolcsonzo;

/*Hozzunk létre egy kölcsönzés táblát! Sorszámmal, hivatkozással a kolcsonzo
táblára és könyvcímmel!*/

CREATE TABLE kolcsonzes(
sorszam NUMBER(5) GENERATED AS IDENTITY PRIMARY KEY
,kolcsonzo NUMBER(3) REFERENCES kolcsonzo (kid)
,konyv VARCHAR2(40)
);

INSERT INTO kolcsonzes(kolcsonzo, konyv)
VALUES(
'10'
,'Ûrutazás'
);

INSERT INTO kolcsonzes(kolcsonzo, konyv)
VALUES(
'10'
,'Ûrutazás2'
);

select * from kolcsonzes;

drop table kolcsonzo purge;

drop table kolcsonzes purge;

CREATE TABLE kolcsonzes(
sorszam NUMBER(5) GENERATED AS IDENTITY PRIMARY KEY
,kolcsonzo NUMBER(3) 
,konyv VARCHAR2(40)
,foreign key (kolcsonzo)REFERENCES kolcsonzo (kid)
);

select * from user_objects;
select * from user_constraints;

/******************/
/*Csoport feladat:*/
/******************/

/*1. A 3 leírás közül a felesleges kettõt töröljék ki, a harmadikat pedig tervezzék
meg az oktatóval közösen!*/

/*A Szálláshely séma instrukciói:

Egy szálláshely közvetítõ oldal egyszerûsített adatbázisát kell 
megterveznünk, amelyben tároljuk a szálláshelyek, az ügyfelek 
és a foglalások adatait. 

Az ügyfeleink magánszemélyek, akik regisztrációval kerülnek 
az adatbázisunkba, ahol meg kell adniuk logint, e-mail címet, 
nevet, születési adatokat, számlázási címet.
Nem lehet két regisztráció azonos e-mail címmel.

A szálláshelyekrõl tárolunk különbözõ adatokat: legyen nevük, 
típusuk, kapacitásuk (szobaszám, összes férõhely), címük, területi 
elhelyezkedésük. 
A szálláshelyeket munkatársaink rögzítik az adatbázisban, így 
legyen egy mezõ, ami a felvivõ azonosítóját tárolja és a felvitel 
dátumát (mindkettõt default).

A szálláshelyek szobáit is tároljuk le külön-külön. Csak alap 
adatok legyenek, azonosító, szobaszám, ágyszám, pótágy, légkondi.

Tároljuk még a foglalások adatait is. Melyik felhasználó, mikor, 
mikorra hány fõ felnõtt, hány fõ gyerekre foglalta. Lehet itt egy 
megjegyzés rovat is.
*/

/*Az Egyetem séma instrukciói:

Egy egyetem egyszerûsített adatbázisát kell megterveznünk, 
amelyben tároljuk a hallgatók adatait, valamint a tárgyakat 
és az abból elért eredményeket. Az eredmények félévekre oszlanak. 

A hallgatókról tároljuk az egyedi azonosítójukat, nevüket, 
születésüket. Ezen kívül a tanulmányaik kezdésének dátumát 
(ami valamelyik év szeptember 1. vagy február 1. lehet), illetve a szakját.

A tantárgyaknak van egyedi kódja, nem feltétlenül egyedi neve, 
kreditértéke és besorolása (kötelezõ, kötelezõen választható, választható), 
tantárgyfelelõse és egy szervezeti egység, amihez tartozik. 
Ezen kívül van egy leírás mezõ is a tantárgyleírás számára.

A hallgatók a tárgyakat különbözõ félévekben vehetik fel és ott 
különbözõ eredményeik lehetnek. Egy tárgyat többször is fel lehet 
venni és egy felvétel alkalmával is több eredmény születhet. 
Az eredmény lehet egy osztályzat, vagy egyéb (nem vizsgázott, 
nem jelent meg, igazoltan nem jelent meg). 

Az eredményeket munkatársaink rögzítik az adatbázisban, így 
legyen egy mezõ, ami a felvivõ azonosítóját tárolja és a 
felvitel dátumát (mindkettõt default).
*/

/*A Webáruház séma instrukciói:

Egy webáruház egyszerûsített adatbázisát kell megterveznünk, 
amelyben tároljuk a termékeket, az ügyfeleket és a rendeléseiket. 

A termékekrõl tárolunk egy egyedi termékkódot, megnevezést, 
listaárat, kategóriát, leírást, melyik raktárunkban van és 
mekkora készletünk van belõle. 
A termékeket munkatársaink rögzítik az adatbázisban, így 
legyen egy mezõ, ami a felvivõ azonosítóját tárolja és a 
felvitel dátumát (mindkettõt default).

A vevõink regisztrációval kerülnek az adatbázisunkba, ahol 
meg kell adniuk logint, e-mail címet, nevet, születési adatokat, 
nemet, számlázási címet. Nem lehet két regisztráció azonos e-mail címmel.

Egy idõben egy rendelést lehet leadni egyféle kiszállítási dátummal, 
móddal és címmel és számlázási címmel, de egy rendelési kosárban több 
tétel is szerepelhet, ahol az ár eltérhet a listaártól.
*/

/*2. Hozzák létre a közösen megtervezett adatbázist!*/

select user from dual;

/*a) Szálláshely*/

SELECT 
'drop '|| object_type ||' '
||object_name
||case when lower(object_type)='table' then ' purge;' else ';' end Lefuttatni
FROM user_objects
where lower(object_type) in ('table','sequence') and lower(generated)='n'
ORDER BY created DESC;

CREATE TABLE ugyfel(
 login VARCHAR2(20) PRIMARY KEY
,nev VARCHAR2(50) NOT NULL
,email VARCHAR2(50) NOT NULL UNIQUE 
  CHECK (email LIKE '%@%.__' OR  email LIKE '%@%.___')
,szuldat DATE
,cím varchar2(100)
);

CREATE TABLE szallashely(
ID NUMBER(3) GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
,nev VARCHAR2(50) NOT NULL
,tipus VARCHAR2(20) 
,csillagok NUMBER(1) CHECK (csillagok BETWEEN 1 AND 5)
,szobaszam NUMBER(4)
,agyszam NUMBER(5)
,hely VARCHAR2(50)
,felvitte VARCHAR2(10) DEFAULT USER NOT NULL
,felvitel_datum date default sysdate not null
);

CREATE TABLE szoba(
szoba_id NUMBER(6) GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
,szallashely NUMBER(3) NOT NULL REFERENCES szallashely(ID)
,szobaszam VARCHAR2(5) NOT NULL
,agyszam NUMBER(2) not null
,potagy NUMBER(2) default 0 CHECK (potagy>=0)
,legkondi VARCHAR2(1) CHECK(legkondi IN ('I','N'))
,UNIQUE(szallashely,szobaszam)
);

CREATE TABLE foglalas(
sorszam NUMBER GENERATED AS IDENTITY PRIMARY KEY
,szoba NUMBER(6) NOT NULL REFERENCES szoba(szoba_id)
,szemely VARCHAR2(20) NOT NULL REFERENCES szemely(login)
,erkezes DATE NOT NULL
,tavozas DATE not null
,felnott_fo NUMBER(2)
,gyermek_fo NUMBER(2)
,megjegyzes CLOB
,CHECK (tavozas>erkezes)
,UNIQUE(szoba,szemely,erkezes)
);

select * from user_objects
order by object_type;

select * from user_constraints
order by table_name, constraint_type;

/*b) Egyetem*/

SELECT 
'drop '|| object_type ||' '
||object_name
||case when lower(object_type)='table' then ' purge;' else ';' end Lefuttatni
FROM user_objects
where lower(object_type) in ('table','sequence') and lower(generated)='n'
ORDER BY created DESC;

create table hallgato(
 neptun varchar2(6) primary key check (length(neptun)=6)
,nev varchar2(50) not null
,szuldat date not null
,szak varchar2(20)
,kezdes date check (to_char(kezdes,'mmdd') in ('0901','0201') )
);

create table tantargy(
 tantargykod varchar2(15) primary key
,tantargy varchar2(50) not null
,kredit number(2) not null check (kredit>=0)
,besorolas varchar2(30) check (besorolas in ('kötelezõ','választható','kötelezõen választható'))
,felelos varchar2(50)
,szervezet varchar2(50)
,leiras clob
);

create table targyfelvetel(
 sorszam number(6) generated as identity primary key
,hallgato varchar2(6) not null references hallgato(neptun)
,tantargy varchar2(15) not null references tantargy(tantargykod)
,felev varchar2(11) not null check (felev like '____/____ 1' or felev like '____/____ 2')
);

create table eredmeny(
targyfelvetel number(6) references targyfelvetel(sorszam)
,hanyadik number(1) not null 
,eredmeny number(1) check (eredmeny between 1 and 5)
,egyeb varchar2(30) check (egyeb in ('nem vizsgázott','nem jelent meg','igazoltan nem jelent meg'))
,felvitte VARCHAR2(10) DEFAULT USER NOT NULL
,felvitel_datum date default sysdate not null
,primary key(targyfelvetel,hanyadik)
,unique(targyfelvetel,felvitel_datum)
,check (eredmeny is not null or egyeb is not null)
);

select * from user_objects
order by object_type;

select * from user_constraints
order by table_name, constraint_type;

/*Webáruház*/

SELECT 
'drop '|| object_type ||' '
||object_name
||case when lower(object_type)='table' then ' purge;' else ';' end Lefuttatni
FROM user_objects
where lower(object_type) in ('table','sequence') and lower(generated)='n'
ORDER BY created DESC;

CREATE TABLE ugyfel(
 login VARCHAR2(20) PRIMARY KEY
,nev VARCHAR2(50) NOT NULL
,email VARCHAR2(50) NOT NULL UNIQUE 
  CHECK (email LIKE '%@%.__' OR  email LIKE '%@%.___')
,szuldat DATE
,nem varchar2(1) check (nem in ('F','N'))
,cim varchar2(100)
,regisztracio date default sysdate
);

create table termek(
 termekkod varchar2(12) primary key
,termeknev varchar2(100) not null
,ar number(10,2) check (ar>=0)
,kategoria varchar2(20) not null
,raktar varchar2(1)
,keszlet number(5) check (keszlet>=0)
,leiras clob
,felvitte VARCHAR2(10) DEFAULT USER NOT NULL
,felvitel_datum date default sysdate not null
);

create table rendeles(
 sorszam number(6) generated as identity primary key
,vevo varchar2(20) references ugyfel(login)
,datum date default sysdate not null
,szall_datum date
,kiszallitas varchar2(10) check (kiszallitas in('posta','GLS','személyes'))
,szall_cim varchar2(100)
,szamla_cim varchar2(100)
,unique (vevo,datum)
,check (szall_datum>=datum)
);

create table rendelesi_tetel(
 rendeles number(6) references rendeles(sorszam)
,termek varchar2(12) references termek(termekkod)
,darabszam number(5) not null check (darabszam>0)
,ar number(10,2) not null
,primary key (rendeles,termek)
);

select * from user_objects
order by object_type;

select * from user_constraints
order by table_name, constraint_type;