--Jogosultságok, Tranzakciók

-- mindenki véglegsítse a döntését a kihívással kapcsolatban ( „még nem döntöttem el” opció törölve lesz) 
-- jelentkezés végsõ határideje május 11. csütörtök 17:30
-- Aki eddig az idõpontig nem jelzi, hogy írni szeretne, az nem jöhet el a pénteki zh-ra
-- Terembeosztás csütörtök este lesz csinálva
-- Kivételesen a közös anyag megbeszélése után rögtön megírjuk a sprintet
-- kötelezõ részek után az óra további része konzultáció
-- a közös feladatgyûjtemény feladatait ajánlom felhasználni


/*1. Hozzuk létre a gyerek táblát az alábbi utasítással!*/

DROP TABLE gyerek PURGE;

CREATE TABLE gyerek
(ID NUMBER(4) GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
,nev VARCHAR2(32) NOT NULL
,nem VARCHAR2(1) CHECK (nem IN ('F','L'))
,iskolas NUMBER(1) DEFAULT 1 CHECK (iskolas IN(0,1))
,kor NUMBER(2)
,felvitte VARCHAR2(16) DEFAULT USER NOT NULL
,felvitel DATE DEFAULT SYSDATE NOT NULL
);
DESC gyerek

/*2. Paraméteres utasítással vigyünk be 2 fiút és 2 lányt a táblába, csak
a nevet és a nemet adjuk meg, a többi alapértelmezett.*/

-- :-al van jelölve a paraméter, felugró ablakban kellmegadni az értéket
-- szövegként lehet megadni, de automatikus tipuskonverzió van
-- minden máshoz van default érték
INSERT INTO gyerek(nev,nem, kor) VALUES(
:a_nev,:b_nemfl, :c_kor
);

COMMIT;

-- az aktuális session paramétereit át lehet állítani
-- dátum megjelenitésének beállítása
ALTER SESSION SET NLS_DATE_FORMAT='mm.dd';

SELECT * FROM gyerek;

/*3. Hozzunk létre egy bevitel nevû nézetet, amelyen keresztül majd más
is tud adatot bevinni a táblánkba. A felvitte és a felvitel adatok mindenképpen
csak alapértelmezettek lehessenek!*/

-- A nézeteknek két nagy felhasználási köre van: egyrészt egyszerûsíthetik a lekérdezéseket: a 
-- beágyazott lekérdezést megcsináljuk külön és névvel látjuk el, majd felhasználjuk abból való lekérdezésre.
-- Másrészt jogosultságkezelésre is lehet alkalmas: bizonyos felhasználói köröknek nem adunk jogosultságot az
-- eredeti táblák olvasására/módosítására, csak a táblákból készített nézetekre. A felhasználó az objektum nevébõl,
-- viselkedésébõl nem fogja tudni, hogy amit használ az éppen tábla vagy nézet. Fontos végiggondolni, hogy
-- a használt nézetek alkalmasak-e DML utasítások szereplõjének. Ez megtiltható explicit is, de vannak nézetek,
-- amelyeken keresztül biztosan nem tudunk DML utasításokat futtatni (pl. aggregát adatokat tartalmaznak).

-- csak azok az oszlopok lettek most felvéve, amiket meg akarok adni (felvitte ezért nincs benne)
-- ha nincs létrehozzza, ha van módosítja
CREATE OR REPLACE VIEW bevitel
AS SELECT  nev, nem, iskolas, kor
FROM gyerek;

/*4. Vigyünk be további 2 rekordot a nézeten keresztül!*/

-- A nézeteken keresztül van lehetõség DML utasítások futtatására is
--  mûvelet mindig a forrás táblára fog vonatkozni
INSERT INTO bevitel VALUES(
:a_nev,:b_nemfl,:c_iskolas10,:d_kor
);

COMMIT;
SELECT * FROM bevitel;
SELECT * FROM gyerek;

/*5. Készítsünk bevitel2 néven különbözõ nézeteket és próbáljuk ki
rajtuk keresztül az adatbevitelt illetve más DML utasításokat!*/

--csak a névbõl
CREATE OR REPLACE VIEW bevitel2
AS SELECT  nev
FROM gyerek;

INSERT INTO bevitel2
VALUES('Szabolcs');

SELECT * FROM bevitel2;
SELECT * FROM gyerek;

COMMIT;

--csak a nembõl
CREATE OR REPLACE VIEW bevitel2
AS SELECT  nem
FROM gyerek;

-- attól függõen, hogy a nézetet milyen definíció hozta létre, nem minden nézet alkalmas minden DML utasításra
-- Az üres (NULL) ide nem szúrható be: ("GI17_KISSAK"."GYEREK"."NEV")
-- mert valójában ide akarunk beszúrni
INSERT INTO bevitel2
VALUES('L');

SELECT * FROM bevitel2;
SELECT * FROM gyerek;

--csak a nevbõl és a nembõl
CREATE OR REPLACE VIEW bevitel2
AS SELECT nev, nem
FROM gyerek;

SELECT * FROM bevitel2;

--törölni is lehet a nézeten keresztül
DELETE FROM bevitel2
WHERE nem IS NULL;

SELECT * FROM bevitel2;
SELECT * FROM gyerek;

COMMIT;

--legyen számított kifejezés a nézetben
CREATE OR REPLACE VIEW bevitel2
AS SELECT  nev, kor+1 kor_jovore
FROM gyerek;

SELECT * FROM bevitel2;

-- virtuális (képzett) oszlop használata itt nem megengedett
-- képzett oszlopon keresztül nem lehet adatot bevinni

INSERT INTO bevitel2 VALUES('Ottó',12);

-- csak nevet iszont tudok felvinni rajta keresztül (a többinél az aalpértelmezett avgy NULL fog szerepelni)
INSERT INTO bevitel2(nev) VALUES('Ottó');

SELECT * FROM bevitel2;
SELECT * FROM gyerek;

COMMIT;

/*6. Készítsünk olyan nézetet, amelybe biztosan nem lehet adatot bevinni!*/

-- A nézet végén a WITH kulcsszó segítségével direktben is meg lehet adni, hogy hogy viselkedjen
-- Ha a nézet megadása végén a WITH READ ONLY kódot adjuk meg, akkor csak olvasható nézetet hozunk létre,
-- ha WITH CHECK OPTION-t, akkor a nézeten keresztül csak úgy módosíthatunk, hogy a nézetet létrehozó feltétel
-- igaz maradjon, ha egyiket sem adjuk meg, akkor bevihetünk/módosíthatunk úgy is adatot, hogy az a nézetet 
-- létrehozó select feltételének nem felel meg, csak az eredeti tábla kényszereinek.
-- A WITH READ ONLY azt fogja jelenteni, hogy nem lehet rajta keresztül módosítani az eredeti tábla tartalmát

CREATE OR REPLACE VIEW bevitel2
AS SELECT nev, nem
FROM gyerek
WITH READ ONLY;

-- A DML- mûvelet nem hajtható végre a csak olvasható nézetben
INSERT INTO bevitel2 VALUES ('Anna','L');

/*7. Készítsünk olyan nézetet, amelyben csak a lányok szerepelnek! Ezután
próbáljunk fiút bevinni a nézeten keresztül!*/

CREATE OR REPLACE VIEW lany AS SELECT nev, nem FROM gyerek
WHERE nem='L';

SELECT * FROM lany;

-- lehet fiút beszúrni rajta keresztül
INSERT INTO lany
VALUES ('Pisti', 'F');

COMMIT;
SELECT * FROM lany;
SELECT * FROM gyerek;

 -- A WITH CHECK OPTION pedig az jelenti, hogy csak úgy lehet a nézeten keresztül módosítani,
 -- hogy a nézetet létrehozó lekérdezésben szereplõ feltételeknek megfeleljenek a keletkezõ 
 -- adatok (insert és update esetén is)
 
CREATE OR REPLACE VIEW lany AS SELECT nev, nem FROM gyerek
WHERE nem='L' WITH CHECK OPTION;

-- a WITH CHECK OPTION-nal létrehozott nézet WHERE feltétele nem teljesül
INSERT INTO lany
VALUES ('Pisti', 'F');

/*Egymás tábláinak használata. Kövessük az oktató utasításait, mert fontos a szinkron!*/

/*8. Kérdezzük le a szomszédunk gyerek táblájának és bevitel nézetének tartalmát!
Ehhez szükségünk lesz az õ sémanevére! Az alulvonások helyére mindig a társunk
sémanevét írjuk be! Miért tudjuk lekérdezni?*/

-- A FELADATOKAT PÁRBAN KELL ELVÉGEZNI
-- Jelenlegi jogosultsági beállítások szerint minden hallgatónak hallgato szerepe (role) van,
-- a hallgato szerepnek pedig van select any table rendszerjogosultsága. Ezért le tudjuk kérdezni
-- bárki tábláit, nézetetit. Az adatok írásához, módosításához viszont nincs jogunk. Jogok adás
-- a a GRANT utasítással történik, visszavonása pedig a REVOKE-kal. 
-- A GRANT szintaktikája: GRANT mit (vesszõvel elválasztva több jogot is adhatunk egyszerre) ON objektum TO felhasználó vagy szerep.
-- REVOKE: REVOKE mit ON objektum FROM felhasználó vagy szerep.

--saját sémanév lekérdezése, ezt kell a ___ helyére beírni
SELECT USER FROM dual;

-- jogosultságok lekérhetõek:  dba/security/users/roles és neki vannak jogai
-- dba/security/roles/sys privileges
SELECT * FROM ___.gyerek;
SELECT * FROM ___.bevitel;


/*9. Vigyünk be a szomszédunk gyerek táblájába a bevitel nézeten keresztül
egy hallgatót!*/

-- nincs megfelelõ jogosultságunk
INSERT INTO ___.bevitel(nev,nem)
VALUES ('Kitti','L');

COMMIT;

/*10. Adjunk jogosultságot a szomszédunknak a saját táblánkra adatbevitelre és
módosításra!*/

-- rengeteg fajta jogosultság van
-- on után, hogy mire
-- to után, hogy kinek
GRANT INSERT, UPDATE ON bevitel TO ___;

/*11. Szúrjunk be egy új rekordot a szomszéd táblájába! 
(Ismételjük meg a 9. feladatot!)*/

INSERT INTO ___.bevitel(nev,nem)
VALUES ('Kitti','L');
COMMIT;

/*12. Szúrjuk be a saját bevitel nézetünk adatait a szomszéd bevitel nézetébe!
Ne véglegesítsük!
Kérdezzük le a szomszéd gyerek tábláját és a sajátunkat is! Ismételjük meg
a két lekérdezést azután is, hogy mindketten kiadtuk a commit parancsot!*/

INSERT INTO ___.bevitel
SELECT * FROM bevitel;

-- A véglegesítés elõtti lekérdezésnél úgy tûnik, mintha a társunk lusta lenne.
-- Mikor az õ tábláját kérdezzük le, akkor látjuk az általunk odaírtakat is, mikor
--a sajátunkat, akkor a társunk adatai hiányoznak. Miután mindketten comittoltunk,
-- akkor látszik az összes adat itt is ott is. Eltérés nyilván lesz: az azonosító
-- sorszámban illetve a felvitel dátumában. 
-- ha a sorszámokat is át akarjuk vinni akkor kulcsegyezés lenne
-- Hogyan lehetett volna ezt megelõzni: ha mondjuk a kulcsérték mindenkinek a 
-- saját sémájában nem egyszerûen a számláló következõ értéke, hanem a felvivõ 
-- felhasználónév és a sorszám együtt.

SELECT * FROM ___.gyerek
ORDER BY ID;
SELECT * FROM gyerek
ORDER BY ID;

COMMIT;

/*13. Módosítsunk a saját táblánkban minden fiút, hogy ne legyen iskolás! 
NE COMMITTÁLJUNK! Módosítsuk a szomszédunk nézetében a Pisti nevû fiúkat úgy,
hogy iskolások legyenek!*/

/*
Forgatókönyv:
a)	Mindketten módosítják a fiúkat commit nélkül!
b)	Mindketten kiadják a Pistit módosító utasítást és mindketten várnak (mert 
    az elõzõ módosítás miatt minden fiú rekordon zár van.
c)	egy rövid idõ után a pár egyik tagjának hibaüzenettel leáll az utasítás: 
    amelyiknél elõbb észreveszi a rendszer, hogy holtpont (deadlock) van, nevezzük
    õt A felhasználónak, a még mindig várakozót pedig B-nek.
d)	mi történt és mi lehet a megoldás? A megoldás az, ha 
    A megszûnteti a zárat. Ezt kétféleképpen teheti meg: vagy commit-tal vagy rollback-kel
    befejezi a tranzakciót. Mivel az eredeti szándék szerint  a tranzakciója két lépésbõl 
    állt volna, azért nem lenne szerencsés fél úton commit-tal fejezni be. Az A felhasználó
    adja ki a Rollback utasítást, a B felhasználónak abban a pillanatban le fog futni az utasítása.
e)	B kész a teljes tranzakcióval, most kiadhatja a COMMIT-ot.
f)	Ezután A lefuttathatja mindkét utasítását egymás után és õ is kiadhatja a COMMIT-ot.
*/

UPDATE bevitel
SET iskolas=0
WHERE nem='F';

UPDATE ___.bevitel
SET iskolas=1
WHERE nev='Pisti';


/*
Nem volt sorbarendezhetõ a két tranzakció, mert A szándéka az volt, hogy a saját táblájában senki 
ne legyen iskolás és a B táblájában Pistik iskolások legyenek. Miután mindkét tranzakció lefutott
a következõ az eredmény:
Idõ	A	B
T1	A fiúi nem iskolásak;	B fiúi nem iskolásak
T2	B Pistik iskolásak - várakozás;	A Pistik iskolásak - várakozás
T3	Deadlock hibaüzenet utasítás szintû rollback;	várakozás
T4	Rollback;	A Pistik iskolásak
T5	A fiúi nem iskolásak (Pistik sem!);
T6	B Pistik iskolásak;
Végeredmény	A fiúi egyáltalán nem iskolásak;	B fiúi a Pistik kivételével nem iskolásak.
 Így A eredeti szándéka teljesült, B eredeti szándéka viszont nem. Ha A T4-kor commit-ált
 volna és csak a második utasítását futtaja újra, akkor B eredeti szándéka teljesült volna és A-é nem.
*/


/*Módosítások a csoport sémájában. Az alulvonások helyére mindig
a saját sémájuk nevét írják be, pl. G01_SZALLASHELY*/

-- A kihagyott részek (___) helyére most mindenkinek majd a csoport sémanevét kell bemásolgatnia

/*14. Vigyük be a saját bevitel nézetünk tartalmát a csoport sémánk
bevitel nézetébe és commitáljunk!*/
INSERT INTO ___.bevitel
SELECT * FROM bevitel;

COMMIT;

SELECT * FROM ___.gyerek;


/*15. Módosítsa mindenki a csoport sémánk bevitel nézetén keresztül
a Pisti nevû gyerekek adatait, hogy biztosan iskolásak legyenek!*/

--mindenki futtassa le, de ne commitáljon

UPDATE ___.bevitel
SET iskolas=1
WHERE nev='Pisti';
COMMIT;

/********************/
/*Gyakroló feladatok*/
/********************/