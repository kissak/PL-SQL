/*1. Hozzunk létre egy sorszámgenerátort (Sequence) 
és kérdezzük le a következõ értékét, aktuális értékét!*/

-- Sorszámgenerátor objektum
-- Segítségével biztosítható, hogy mindig különbözo értéket tudjunk kiolvasni
-- A sorszámgenerátornak kötelezoen csak nevet kell adnunk, de opcionálisan megadhatunk rengeteg mást is (dokumentációban lehet bogarászni)
-- A legöbb dolognak egyértelmu a megnevezése, mondjuk a START WITH (kezdoérték), INCREMENT BY (lépésköz)

CREATE SEQUENCE sorszámpróba START WITH 1000 INCREMENT BY 10;

-- A sorszámgenerátor következo értékét így lehet lekérdezni:
SELECT sorszámpróba.nextval FROM dual;

-- Az aktuális értéket is le lehet kérdezni, a nextval helyett currval-lal
-- ez minden sessionben csak azután muködik, hogy már volt lekérdezve nextval az adott sessionben
SELECT sorszámpróba.currval FROM dual;

/*2. Töröljük ki az összes táblánakat és sorozatunkat!*/

-- a ALL_TABLES és párja a USER_TABLES mellett nagyon hasznos ismerni az ALL_OBJECTS és USER_OBJECTS katalógustáblákat is
-- Itt nem csak a tábláinkat látjuk, hanem minden objektumot
-- A második select valójában egyetlen elemet tartalmaz: szövegösszefuzéssel egy drop utasítást 
-- A drop utasítás változó elemeit a USER_OBJECTS táblából kérdezzük le, azaz az objektum típusát, nevét, illetve ha a típus tábla, akkor a PURGE kulcsszót is odaírjuk a végére 
-- A where-ben megadjuk, hogy csak tábla vagy sequence típus és csak a nem generáltak. 
-- a rendezés azt mondja, hogy fordított sorrendben dobjuk el az objektumokat, mint ahogy létrehoztuk oket. 
-- Ez azért jó, mert akkor nagy valószínuséggel az egymásra hivatkozó táblákat is jó sorrenben sikerül majd eldobnunk.
-- Lefuttatás után az eredményül kapott utasításokat ctr+c ctr+v segítségével visszamásolhatjuk a worksheetre és kijelölés után egyben le tudjuk oket futtatni. 
-- Csak a tábláinkat és a sorszámainkat dobjuk el (abból is csak azokat, amiket mi generáltunk – egyelore még csak ilyenünk lesz)
-- mégis ha újra lekérdezzük a USER_OBJECTS-et, akkor azt látjuk, hogy az indexek is eltuntek.

SELECT * FROM user_objects
ORDER BY object_type;

SELECT 
'drop '|| object_type ||' '
||object_name
||case when lower(object_type)='table' then ' purge;' else ';' end Lefuttatni
FROM user_objects
where lower(object_type) in ('table','sequence') and lower(generated)='n'
ORDER BY created DESC;

select * from user_objects;

/*3. Hozzunk létre egy KOLCSONZO táblát, azonosító és név legyen benne. 
Az azonosító automatikusan generálódjon!*/


-- Always vagy elhagyás esetén nem is enged semmit beírni az oszlopba, by default esetén csak üresen hagyáskor írja felül, ON NULL esetén értékként megadott NULL-t is felülírja
-- Akár így, akár úgy, automatikusan not null lesz
-- A háttérben egy sequence jön létre, ha törlünk, újra beszúrunk, akkor a számláló automatikusan tovább megy
-- Láthatjuk a dokumentációban identity_options-ként kb. ugyanazokat a tulajdonságokat lehet megadni, amit a sequence-nél
-- Ezek a háttérben automatikusan létrejövo sequence tulajdonságai lesznek


CREATE TABLE kolcsonzo
(kid NUMBER(4) GENERATED AS IDENTITY PRIMARY KEY
,nev VARCHAR2(40));

INSERT INTO kolcsonzo
VALUES(
10
,'Mézga Géza'
);

INSERT INTO kolcsonzo(nev)
VALUES('Mézga Géza');
INSERT INTO kolcsonzo(nev)
VALUES('Mézga Aladár');
INSERT INTO kolcsonzo(nev)
VALUES('Hufnágel Pisti');

SELECT * FROM kolcsonzo;
ROLLBACK;

COMMIT;


DROP TABLE kolcsonzo PURGE;

CREATE TABLE kolcsonzo
(kid NUMBER(4) GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY
,nev VARCHAR2(40));

INSERT INTO kolcsonzo
VALUES(
10
,'Mézga Géza'
);


INSERT INTO kolcsonzo(nev)
VALUES('Mézga Géza');
INSERT INTO kolcsonzo(nev)
VALUES('Mézga Aladár');
INSERT INTO kolcsonzo(nev)
VALUES('Hufnágel Pisti');

SELECT * FROM kolcsonzo;

/*Hozzunk létre egy kölcsönzés táblát! Sorszámmal, hivatkozással a kolcsonzo
táblára és könyvcímmel!*/

-- Inline simán REFERENCES és megadni az objektumot és annak oszlopát, amire hivatkozunk (ha az oszlopot elhagyjuk, akkor az azonos nevu oszlopra hivatkozik)
-- Fontos, hogy a hivatkozó mezo és a hivatkozott mezo adattípusa azonos legyen (mezoméret mindegy)
-- alapértelmezetten hivatkozott értéket nem lehet kitörölni a hivatkozott táblából
-- ha viszont az idegenkulcsot ON DELETE klauzulával hozzuk létre, akkor mégis van lehetoség törlésre. 
-- A CASCADE tovagyuruzést jelent, azaz a hivatkozó rekordok is automatikusan törlodnek.
-- Vigyázat! Nem a törléskor tudom eldönteni, hogy akarok-e tovagyuruzést, hanem az idegen kulcs definiálásakor! 
-- A SET NULL azt jelenti, hogy a hivatkozott adat törlésekor a hivatkozó táblában NULL érték lesz, csak akkor van értelme beállítani, ha egyébként az adott mezore nincs NOT NULL feltétel
-- Idegen kulcs csak másik tábla UNIQUE tulajdonságú mezojére hivatkozhat (nem feltétlenül kell a hivatkozott mezonek kulcsnak lenni), azaz a null érték megengedett. 
-- az adattípusnak meg kell egyezni
-- létezik több oszlopos idegen kulcs is
-- a hivatkozó és hivatkozott oszlopok darabszámának meg kell egyezni és ebben az esetben az oszlopok kombinációjának kell UNIQUE-nak lenni a hivatkozott táblában (ezt csak out-of-line lehet megadni)
-- Out-of-line megadásnál szükséges a FOREIGN KEY (mezolista) megadása is, hogy meg tudjuk jelölni, hogy melyik oszlop (esetleg oszlopkombináció) lesz az idegen kulcs
-- A mintapéldában van inline és out-of-line is, a végeredmény ugyanaz lesz


--inline
CREATE TABLE kolcsonzes(
sorszam NUMBER(5) GENERATED AS IDENTITY PRIMARY KEY
,kolcsonzo NUMBER(3) REFERENCES kolcsonzo (kid)
,konyv VARCHAR2(40)
);

INSERT INTO kolcsonzes(kolcsonzo, konyv)
VALUES(
'10'
,'Ûrutazás'
);

INSERT INTO kolcsonzes(kolcsonzo, konyv)
VALUES(
'10'
,'Ûrutazás2'
);

select * from kolcsonzes;

drop table kolcsonzo purge;

drop table kolcsonzes purge;

--out-of-line
CREATE TABLE kolcsonzes(
sorszam NUMBER(5) GENERATED AS IDENTITY PRIMARY KEY
,kolcsonzo NUMBER(3) 
,konyv VARCHAR2(40)
,foreign key (kolcsonzo)REFERENCES kolcsonzo (kid)
);

select * from user_objects;
select * from user_constraints;

/******************/
/*Csoport feladat:*/
/******************/

/*1. A 3 leírás közül a felesleges kettõt töröljék ki, a harmadikat pedig tervezzék
meg az oktatóval közösen!*/

/*Az Egyetem séma instrukciói:

Egy egyetem egyszerûsített adatbázisát kell megterveznünk, 
amelyben tároljuk a hallgatók adatait, valamint a tárgyakat 
és az abból elért eredményeket. Az eredmények félévekre oszlanak. 

A hallgatókról tároljuk az egyedi azonosítójukat, nevüket, 
születésüket. Ezen kívül a tanulmányaik kezdésének dátumát 
(ami valamelyik év szeptember 1. vagy február 1. lehet), illetve a szakját.

A tantárgyaknak van egyedi kódja, nem feltétlenül egyedi neve, 
kreditértéke és besorolása (kötelezõ, kötelezõen választható, választható), 
tantárgyfelelõse és egy szervezeti egység, amihez tartozik. 
Ezen kívül van egy leírás mezõ is a tantárgyleírás számára.

A hallgatók a tárgyakat különbözõ félévekben vehetik fel és ott 
különbözõ eredményeik lehetnek. Egy tárgyat többször is fel lehet 
venni és egy felvétel alkalmával is több eredmény születhet. 
Az eredmény lehet egy osztályzat, vagy egyéb (nem vizsgázott, 
nem jelent meg, igazoltan nem jelent meg). 

Az eredményeket munkatársaink rögzítik az adatbázisban, így 
legyen egy mezõ, ami a felvivõ azonosítóját tárolja és a 
felvitel dátumát (mindkettõt default).
*/


/*2. Hozzák létre a közösen megtervezett adatbázist!*/
