/*1. Dobjuk el az össze objektumunkat!*/

SELECT 
'drop '|| object_type ||' '
||object_name
||CASE WHEN lower(object_type)='table' THEN ' purge;' ELSE ';' END lefuttatni
FROM user_objects
WHERE lower(GENERATED)='n'
ORDER BY created DESC;
--A futtatással keletkezett utasításokat ide kell másolni és azokat is lefuttatni.



-- mindenféle mûveleteket fogunk végrehajtani táblákon elõször index nélkül, aztán különbözõ indexek meglétével
-- SET AUTOTRACE ON sql plus parancs segítségével minden mûveletnek meg fogjuk nézni a végrehajtási tervét (execution plan)
-- Ahhoz pedig, hogy lássunk adatokat az indexekrõl a statisztikát is meg kell csinltatnuk a rendszerrel
-- A kézzel létrehozott statisztikákra azonnal készül elemzés, de a tábladefinícióval létrejövõ indexek 
-- létrejöttükkor ugye üresek és a statisztikák nem készülnek el minden dml mûvelet után automatikusan 
-- (mert akkor több idõt töltene a rendszer stat készítéssel, mint a felhasználók kiszolgálásával)


/*2. Hozzuk létre egy kereskedelmi adatbázis tábláit és töltsük fel adatokkal!*/
-- Nem másolással hozzuk létre a táblákat, hogy a kényszerek is meglegyenek
CREATE TABLE ugyfel(
 login VARCHAR2(20) CONSTRAINT pk_ugyfel_login PRIMARY KEY
,email VARCHAR2(50) CONSTRAINT nn_ugyfel_email NOT NULL 
  CONSTRAINT u_ugyfel_email UNIQUE 
  CONSTRAINT con_ugyfel_email CHECK (email LIKE '%@%.__' OR  email LIKE '%@%.___')
,vnev VARCHAR2(50) CONSTRAINT nn_ugyfel_vnev NOT NULL
,knev VARCHAR2(50) CONSTRAINT nn_ugyfel_knev NOT NULL
,szulev NUMBER(4)
,cim VARCHAR2(100)
);

INSERT INTO ugyfel SELECT * FROM minta.ugyfel;
COMMIT;

CREATE TABLE termek(
 termekkod VARCHAR2(12) CONSTRAINT pk_termek_termekkod PRIMARY KEY
,megnevezes VARCHAR2(100) CONSTRAINT nn_termek_megnevezes NOT NULL
,listaar NUMBER(10,2) CONSTRAINT con_termek_liataar CHECK (listaar>=0)
,kategoria VARCHAR2(20) CONSTRAINT nn_termek_kategoria NOT NULL 
,leiras CLOB
,raktar VARCHAR2(1)
,keszlet NUMBER(5) CONSTRAINT con_termek_keszlet CHECK (keszlet>=0)
,mennyisegi_egys VARCHAR2(8)
,felvitte VARCHAR2(10) DEFAULT USER CONSTRAINT nn_termek_felvitte NOT NULL
,felvitel_datum DATE DEFAULT SYSDATE CONSTRAINT nn_termek_felviteldatum NOT NULL
);

INSERT INTO termek SELECT * FROM minta.termek;
COMMIT;

CREATE TABLE rendeles(
 rendelessorszam NUMBER(6) GENERATED BY DEFAULT  AS IDENTITY (START WITH 28086)
 CONSTRAINT pk_rendeles_rendelessorszam PRIMARY KEY
,login VARCHAR2(20) CONSTRAINT fk_rendeles_login REFERENCES ugyfel(login)
,rendelesi_ido DATE DEFAULT SYSDATE CONSTRAINT nn_rendeles_rendelesiido NOT NULL
,szallitasi_datum DATE
,szallitasi_mod VARCHAR2(20) CONSTRAINT con_rendeles_szallitasimod CHECK (szallitasi_mod IN('Posta','GLS','Személyes átvétel'))
,CONSTRAINT u_rendeles_login_rendelesiido UNIQUE (login,rendelesi_ido)
,CONSTRAINT con_rendeles_datumok CHECK (szallitasi_datum>=rendelesi_ido)
);

select * from rendeles;

INSERT INTO rendeles
SELECT * FROM minta.rendeles;
COMMIT;

CREATE TABLE rendelesi_tetel(
 rendeles NUMBER(6) CONSTRAINT fk_rendtetel_rendeles REFERENCES rendeles(rendelessorszam)
,termekkod VARCHAR2(12) CONSTRAINT fk_rendtetel_termekkod REFERENCES termek(termekkod)
,egysegar NUMBER(10,2) CONSTRAINT nn_rendtetel_egysegar NOT NULL
,mennyiseg NUMBER(5)
 CONSTRAINT nn_rendtetel_mennyiseg NOT NULL
 CONSTRAINT con_rendtetel_mennyiseg CHECK (mennyiseg>0)
,CONSTRAINT pk_rendtetel_rendeles_termek PRIMARY KEY (rendeles,termekkod)
);

INSERT INTO rendelesi_tetel
SELECT * FROM minta.rendelesi_tetel;
COMMIT;

/*3. Kérdezzük le az indexeink adatait a katlógustáblákból!*/

-- létezik egy katalógustábla a katalógustáblákról
-- Ebben meg tudjuk nézni, hogy milyen indexes katalógusaink vannak
SELECT * FROM dict
WHERE table_name LIKE 'USER_IND%';

-- Ebbõl érdekes lehet a USER_INDEXES, a USER_IND_COLUMNS és a USER_IND_STATISTICS
-- Ha most megnézzük, akkor a pk és unique kényszerekkel automatikusan létrejött indexeket fogjuk látni
-- Az index neve megegyezik a kényszer nevével (ha csak nem adunk meg mást).
-- Most szándékosan nevesített kényszerek lettek készítetve, hogy könnyebb legyen követni. 
-- Index kézi létrehozásakor mindenféleképpen kell nevet adni.
-- névkonvenciót: a kényszer neve a kényszerre utaló elõtaggal kezdõdik (PK_, U_, FK_, CON_, NN_), az indexeké pedig IND_ elõtaggal. 
-- Mivel mindkettõ konkrét táblához kapcsolódik, ezért a tábla nevét is bele 
-- szokas venni az elnevezésbe és aztán a konkrét kényszerre, vagy az index oszlopaira vonatkozó névrész következik. 
-- Ettõl persze el lehet térni, de így logikus és követhetõ.


-- Ismétlés indexel csoportosítása

-- egyedi-e:
-- Ha nem egyedi, akkor elméleti síkon még mindig megkülönböztethetjük a szelektív és nem szelektív indexeket,
-- ami annyit jelent, hogy elõbbi esetben kevés az ismétlõdés, az utóbbiban meg sok. Az OLTP adatbázisokban 
-- jellemzõen B fa típusú indexeket használunk, ezeket NORMAL típusúként tûnteti fel a katalógus. A nem szelektív
-- oszlopokra lehet létjogosultsága ehelyett a BITMAP indexnek, de OLTP rendszerekben nem hatékony. Azért fogun
-- k ilyet is nézni, de majd az utolsó héten, amikor kicsit fogunk tranzakciókkal játszani, akkor fogjuk azt is
-- demonstrálni, hogy milyen gondokat tud okozni egy bitmap index.


-- A másik csoportosítás aszerint lehet, hogy egyoszlopos (egyszerû), vagy többoszlopos 
-- (másnéven összetett vagy konkatenált) az index. A rendeles és a rendelesi_tetel táblákban látunk egy-egy 
-- kétoszlopos kulcsot, amire értelemszerûen kétoszlopos index jött létre. Általában a gyakran együtt lekérdezett
-- oszlopokra érdemes összetett indexet létrehozni. A sorrend nem mindegy. Általában a szelektívebbet érdemes elõre
-- venni, illetve azt, amelyikre önmagában is gyakran fogalmazunk meg feltételt. Azt, hogy az index milyen oszlopokra
-- épül a USER_IND_COLUMNS katalógustáblából kérdezhetjük le (ezt spórolhatjuk meg, ha eleve az index nevébe beleírjuk
-- az oszlopneveket is). Természetesen más infók is kiderülnek abból a táblából.

SELECT * FROM user_indexes
ORDER BY table_name;
SELECT * FROM user_ind_columns
ORDER BY table_name, column_position;
SELECT * FROM user_ind_expressions
ORDER BY table_name;
SELECT * FROM user_ind_statistics
ORDER BY table_name, index_name;

/*4.	Készíttessünk a rendszerrel statisztikát! A Connections ablakban
minden táblánk gyorsmenüjében Statistics/Gather statistics,
majd futassuk le a 3. feladat lekérdezéseit újra!*/


-- készítsen statisztikát, majd újra megnézzük az indexeink adatait. 
-- Ha a táblákra készítünk statisztikát, akkor automatikusan a tábla indexeire is. 
-- De kérhetünk csak index statisztikát is külön-külön.
-- vizsgán nem kell statisztikát készíteni
-- Tehát Connections ablak, táblák. Táblákon egyesével jobb egérgomb. Statistics/Gather statistics.
-- Most futassuk le újra a USER_INDEXES lekérdezését. 
-- elõadás alapján értelmezni tudni kell kell:
-- user_indexes: index_type, uniqueness
-- user_ind_statistics: blevel, leaf_blocks, distinct_keys, avg_leaf_blocks_per_key, avg_data_blocks_per_key, num_rows, last_analyzed


-- Látni fogjuk pl. hogy hány különbözõ érték szerepel az indextáblákban (DISTINCT KEYS). 
-- Látjuk azt is, hogy a B-fa hány szintes (BLEVEL), illetve hogy hány szekvenciális indexlap van 
-- (levelek – leaves)(LEAF_BLOCKS) Az ügyfél tábla login és e-mail indextáblája is elfér egy-egy blokkban,
-- így ott még egyáltalán nem épül egyetlen b-fa szint sem. A termék tábla pk-ja már 2 blokkban fér csak el,
-- így ott már megjelenik a B-fa elsõ szintje, de a rendelés tábla pk 144 blokkjához is még elég egyetlen B-fa
-- szint. A rendelési tétel tábla elsõdleges kulcsának pl. a B-fája már 2 szintû. Alternatív kulcsoknál a különbözõ
-- értékek száma megegyezik, az index mérete mégis lehet különbözõ az indexértékek méretkülönbsége miatt (pl. a 
-- rendelés táblában a pk egyoszlopos, 28085 különbözõ érték és a levelek 93 blokkban férnek el, míg az alternatív 
-- kulcsunk kétoszlopos: login és rendelési idõ együtt, nyilván ez is 28085 különbözõ értéket tartalmaz, de 144 
-- blokkban fér csak el.). Az elsõ (AVG_LEAF_BLOCKS_PER_KEY) a kulcsértékenként érintett átlagos indexblokk szám.
-- Természetesen egyedi indexeknél ez értelemszerûen 1, ahogy a második is (AVG_DATA_BLOCKS_PER_KEY), azaz az
-- adatrekordok átlagos száma kulcsértékenként is. Esetleg ezt a statisztikát majd vissza lehet nézni azután,
-- hogy csináltunk nem egyedi indexet is, mert ott már érdekesek lehetnek ezek a számok. Azt mutatják, hogy
-- mennyire szelektív az index. Az utolsó két bekarikázott oszlop egyértelmû, az indextábla sorainak száma, 
-- illetve a statisztika készítésének a dátuma.
-- Egy mezei felhasználó nem szokta ezeket a statisztikákat nézegetni, inkább csak azért nézzük meg ezeket,
-- hogy kézzelfoghatóbb legyen az, amit az elõadáson hallottak indexekrõl. A statisztikák a lekérdezés-optimalizáló
-- számára fontosak. Amikor mi kiadunk egy select utasítást, akkor az Oracle a háttérben ezeknek a statisztikáknak
-- az alapján dönti el, hogy milyen módon adja meg a választ. Melyik where feltételt értékelje ki elõször, join esetén
-- melyik táblán menjen végig elõször, stb



/*5. Kapcsoljuk be a nyomkövetést és kérdezzük le az 
ugyfel táblából az azonosítót, a vezeték és keresztneveket! 
Ismételjük meg a lekérdezést különbözõ szûrõfeltételekkel, 
és vizsgáljuk meg az Execution plan információit!*/

set autotrace on
select login,vnev,knev from ugyfel;

-- Az utasításainkat RUN SCRIPT-tel futtassuk.
-- Most nem maga az eredmény lesz érdekes, hanem azok az infók, amiket utánaír a script outputban. 
-- Egyrészt a mûveletek listája: innen látjuk, hogy milyen részmûveletekre oszlott a mûvelet (statement), 
-- és azok milyen sorrendben történtek. Ezen kívül a Cost oszlop szolgál információval a költségrõl, 
-- aminek nincs kézzelfogható mértékegysége, de összehasonlításra szolgál. Egyébként a cpu és az I/O költségbõl
-- kalkulálja valamilyen módon. Látni fogjuk, hogy nem minden esetben használja fel az indexeinket, ilyenkor 
-- teljes táblaolvasás van. Nyilván a tábla méretétõl is függ az, hogy milyen különbséget jelent az index scan a 
-- tábla scan-hez képest. Fogunk látni példát arra, hogy az összetett indexet csak az abban szereplõ elsõ oszlopra 
-- vonatkozó szûrésnél tudjuk felhasználni, a második oszlop szerint nem. Fogunk készíteni függvény alapú indexet is.
-- A terv alatti statisztikákat nem fogjuk nézni.
-- Az plan olvasási módja: a felsõ sorban látszik a mûvelet teljes költsége, 
-- illetve a ROWS oszlopban, hogy a statisztikák alapján mit gondol az Oracle, hogy hány eredményrekordunk lesz. 
-- A beljebb kezdett sorok az egyes mûveletek részmûveletei. Az olvasást tehát a részmûveletektõl kell kezdeni. 
-- A költségek pedig úgy alakulnak, hogy a részmûveletek költségeinek összege adja ki a fõbb mûveletek költségét. 
-- Természetesen kerekítési hiba miatt ez nem mindig pontos.
-- Mivel az ügyfél tábla nagyon kicsi, nem lesz számottevõ különbség a cost-ban, de annyit azért látunk, 
-- hogy melyikeknél használt indexet

/*a.	csak a Krisztina keresztnevûeket*/
--a keresztnévre nincs index
select login,vnev,knev from ugyfel
where knev='Krisztina';

/*b.	csak a krisztina login-hoz tartozót*/

select login,vnev,knev from ugyfel
where login = 'krisztina';

/*c.	csak azokat, amelyeknek a loginja krisztina 
karaktersorral kezdõdnek*/

select login,vnev,knev from ugyfel
where login like 'krisztina%';

/*d.	csak azokat, melyek loginjában szerepel 
a krisz karaktersor*/
--nem feltétlenül a mezõ elején van, tehát nem megy sokra az abc sorrendû indexszel
select login,vnev,knev from ugyfel
where login like '%krisz%';

/*6.	Kérdezzük le a rendeles táblából a rendelés 
sorszámát, idejét (másodperce pontosan) és az ügyfél 
azonosítóját (login)! Ismételjük meg a lekérdezést 
különbözõ szûrõfeltételekkel, és vizsgáljuk meg az 
Execution plan információit!*/

desc rendeles
select rendelessorszam, to_char(rendelesi_ido,'yyyy.mm.dd hh24:mi:ss') rendelesi_ido, login ugyfel_azonosito
from rendeles;

/*a.	csak a 100-as sorszámút*/
-- INDEX UNIQUE SCAN
select rendelessorszam, to_char(rendelesi_ido,'yyyy.mm.dd hh24:mi:ss') rendelesi_ido, login ugyfel_azonosito
from rendeles
where rendelessorszam=100;

/*b.	csak a 100-nál kisebb sorszámúakat*/
-- INDEX RANGE SCAN 
select rendelessorszam, to_char(rendelesi_ido,'yyyy.mm.dd hh24:mi:ss') rendelesi_ido, login ugyfel_azonosito
from rendeles
where rendelessorszam<100;

/*c.	csak az 5000-nél kisebb sorszámúakat*/
--  INDEX RANGE SCAN
select rendelessorszam, to_char(rendelesi_ido,'yyyy.mm.dd hh24:mi:ss') rendelesi_ido, login ugyfel_azonosito
from rendeles
where rendelessorszam<5000;

/*d.	csak a 6000-nél kisebb sorszámúakat*/
-- már nem fogja az indexet használni, mert nem elég szelektív a kérdés
-- TABLE ACCESS FULL
select rendelessorszam, to_char(rendelesi_ido,'yyyy.mm.dd hh24:mi:ss') rendelesi_ido, login ugyfel_azonosito
from rendeles
where rendelessorszam<6000;

/*e. csak a megadott másodpercben leadott rendelést*/
-- azért nem tud indexet használni, mert a rendelési idõre nincs indexünk, csak a loginnal párban,
-- de az nem rendelési idõre, hanem loginra rendezett, hiszen az van az összefûzésben elöl

select rendelessorszam, to_char(rendelesi_ido,'yyyy.mm.dd hh24:mi:ss') rendelesi_ido, login ugyfel_azonosito
from rendeles
where rendelesi_ido=to_date('2015.05.03 14:23:58','yyyy.mm.dd hh24:mi:ss');

/*f. csak az INSTVANV loginú vásárló rendeléseit*/
-- ha valóban, ha olyat kérdezünk le, ami az összetett indexben elöl van, akkor azt fel tudja használni a kereséshez
select rendelessorszam, 
to_char(rendelesi_ido,'yyyy.mm.dd hh24:mi:ss') rendelesi_ido, 
login ugyfel_azonosito
from rendeles
where login='ISTVANV';

/*g. Ha gyakran kérdezünk le renedelési idõ alapján, login nélkül, akkor 
érdemes lehet a rendelési idõre külön is indexet készíteni. Vigyázat, 
ez már nem lesz unique! Hozzuk létre explicit módon és kérdezzünk le 
újra egy pontos idõpontot és egy nap rendeléseit is.*/

create index ind_rendido on rendeles(rendelesi_ido);

-- az elõzõ pontok tanulságaira alapozva hozunk létre indexet külön csak a rendelési idõre. 
-- Ha pontos idõre kérdezünk, akkor nyilván segíteni fog, de ha napra, akkor már nem látja elég segítségnek az indexet

-- INDEX RANGE SCAN
select rendelessorszam, 
to_char(rendelesi_ido,'yyyy.mm.dd hh24:mi:ss') rendelesi_ido, 
login ugyfel_azonosito
from rendeles
where rendelesi_ido=to_date('2015.05.03 14:23:58','yyyy.mm.dd hh24:mi:ss');

--TABLE ACCESS FULL
select rendelessorszam, 
to_char(rendelesi_ido,'yyyy.mm.dd hh24:mi:ss') rendelesi_ido, 
login ugyfel_azonosito
from rendeles
where trunc(rendelesi_ido)=to_date('2015.05.03','yyyy.mm.dd');

/*h. Dobjuk el az elõbb létrehozott indexet és hozzunk helyette létre 
explicit módon egy függvény alapú indexet a rendelési idõre
az idõadatok nélkül. Természetesen ez sem unique, majd ismételjük meg az utolsó
két lekérdezést!*/

-- Cseréljük le az elõzõ indexet egy függvény alapú indexre, ahol csak a napokig vesszük
-- az indexértékeket és ismételjük meg az elõzõ két lekérdezést. Látjuk, hogy ez az index 
-- mindkét lekérdezéshez felhasználásra került

drop index ind_rendido;
create index ind_rendnap on rendeles(trunc(rendelesi_ido));

-- INDEX RANGE SCAN
select rendelessorszam, 
to_char(rendelesi_ido,'yyyy.mm.dd hh24:mi:ss') rendelesi_ido, 
login ugyfel_azonosito
from rendeles
where rendelesi_ido=to_date('2015.05.03 14:23:58','yyyy.mm.dd hh24:mi:ss');

-- INDEX RANGE SCAN
select rendelessorszam, 
to_char(rendelesi_ido,'yyyy.mm.dd hh24:mi:ss') rendelesi_ido, 
login ugyfel_azonosito
from rendeles
where trunc(rendelesi_ido)=to_date('2015.05.03','yyyy.mm.dd');

/*7. Hozzuk újra létre az eldobott indexet is 
és kérdezzük le újra az indexeink tulajdonságait!
Majd a felelslegesnek tûnõ indexet dobjuk el újra!*/

-- Az indexek mérete nagyon nagy, a táblák sok esetben jóval több oszlopot tartalmaznak,
-- és akkor a táblaméret-indexméret arány jobban néz ki, de az indexek bizony helyigényesek.

create index ind_rendido on rendeles(rendelesi_ido);
select * from user_indexes
order by table_name, index_name;
drop index ind_rendido;

/*8. Kérdezzük le a termékeink azonosítóját, nevét 
és a belõlük leadott rendeléseket. Ismételjük meg a lekérdezést
különbözõ szûrésekkel!*/

desc termek
desc rendelesi_tetel

select termekkod, megnevezes, rendeles, egysegar, mennyiseg
from termek join rendelesi_tetel using(termekkod);

/*a. csak a kabátok rendelése*/

-- a join megvalósítására különbözõ algoritmusok léteznek, ezek egyike a hash

select termekkod, megnevezes, rendeles, egysegar, mennyiseg
from termek join rendelesi_tetel using(termekkod)
where megnevezes like '%kabát%'
;

/*b. csak az F001-KB101 termékkódú termék rendelése*/
-- igénybe veszi az pk-ra épülõ indexet

select termekkod, megnevezes, rendeles, egysegar, mennyiseg
from termek join rendelesi_tetel using(termekkod)
where termekkod = 'F001-KB101';

/*c. készítsünk indexet a rendelési_tétel táblában a termékkódra*/
-- felmerülhet, hogy érdemes indexet tenni az idegenkulcsra is (termékkód a rendelési tétel táblában),
-- de látni fogjuk, hogy nem elég szelektív (570 termékhez kb. 170ezer rendelési tétel tartozik)

create index ind_rendtetel_termekkod on rendelesi_tetel(termekkod);

select termekkod, megnevezes, rendeles, egysegar, mennyiseg
from termek join rendelesi_tetel using(termekkod)
where termekkod = 'F001-KB101';

/*d. cseréljük le az elõzõ indexet bitmap indexre! Nézzük is meg az összes indexünket.*/

-- el kell dobnunk az indexet, hogy bitmap-ként létrehozzuk újra. Kb. harmadára fog csökkenni a
-- lekérdezés költsége. Úgy tûnhet, hogy nagyon hatékony. Majd az utolsó órán tranzakciókat nézünk
-- és akkor fogunk rádöbbenni a bitmap index kárára (miszerint ha törlünk, módosítunk egy tranzakcióban,
-- az túl nagy részét zárolja az adatbázisnak, mert a bitmap index a b-fával szemben nem soronként
-- zárolódik, és így komoly fennakadást okozunk a többi tranzakcióban)


drop index ind_rendtetel_termekkod;
create bitmap index ind_rendtetel_termekkod_bitmap on rendelesi_tetel(termekkod);

select termekkod, megnevezes, rendeles, egysegar, mennyiseg
from termek join rendelesi_tetel using(termekkod)
where termekkod = 'F001-KB101';

 -- az látszik, hogy bár ugyanarra a táblára készült, a bitmap indexnek nem 160ezer sora van,
 -- csak 550 és bár az indexértékek is kisebbek (hiszen a pk-ban is a termékkód van, csak nem elsõ
 -- mezõként, hanem másodikként), a levélblokkok száma is nagyságrenddel kevesebb

select * from user_indexes
order by table_name, index_name;


-- Dobjunk el minden objektumot, hogy az össz tárhelyünk ne fogyjon el!!

/*Önálló feladat*/

/*1. Kérdezzük le a 4 tábla joinjával, hogy az ügyfeleink 
összesen hány alakalommal rendeltek különbözõ termékkódú kabátokat
és összesen mekkora mennyiségben!*/

/*2. Készítsünk olyan indexeket amelyek lecsökkentik a fenti 
lekérdezés költségét! Ha nincs elég tárhelyünk, akkor dobjunk el olyan
indexeket, amelyek ehhez a lekérdezéshez nem kellenek!*/

/*3.	Ismételjük az elõzõ gyakorlatok gyakorló feladatait!*/